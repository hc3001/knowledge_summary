#### 1、假如我在一个for循环中改变当前组件依赖的数据，改变一万次，会有什么效果？(讲到批量更新和 nextTick 原理)

#### 2、vue-router路由的原理
hash: 使用 URL hash 值来作路由， 触发"hashchange" 事件。（默认）
https://zhuanlan.zhihu.com/p/106206940 (原理)

history: 依赖 HTML5 History API 和服务器配置。
history api 原理 触发"popState" 事件 
https://zhuanlan.zhihu.com/p/106206940 (原理)

#### 3、你觉得 React 和 Vue 有什么共通之处？

#### 4、你说你看过 Vue 源码，能不能介绍一下 Vuex 的 Mutation 和 Action 的区别吗？(mutation做同步操作，action一般用于异步)

#### 5、为什么要设计出 Mutation 和 Action 这两个东西？(代码隔离，devtool异步操作容易追踪)

#### 7、vue编译相关看法

vue.js 在不同的平台下都会有编译的过程，因此编译过程中的依赖的配置baseOptions 会有所不同。

一、生成ast
1、parse 流程
2、parse 目标
3、ast 创建过程， ast 是对模板的描述，是一种抽象语法树，是对源代码的抽象语法结构的树状表现形式。

二、优化生成的ast

三、根据ast生成可执行函数（render 函数）

#### 8、Vue 是如何实现数据双向绑定的？
一、原理：通过Object.defineProperty 方式进行属性拦截，把data里面的每个数据的读和写转化为getter/setter，当数据变化时通知视图更新。
二、基本过程： 1、实现一个监听器observer，用来监听拦截data数据， 如果属性发生变化，通知订阅者。
             2、实现一个订阅者watcher，可以收到属性的变化，并执行相应的方法，从而更新视图。
             3、实现一个订阅器dep，用来收集订阅者，对observer和watcher进行管理。
             4、实现一个compile，用来解析每个节点的相关指令，对模板数据和订阅器进行初始化。
             https://www.jianshu.com/p/70b06d82ccfc
             https://juejin.cn/post/6844903903822086151#heading-13

             vue 实际过程(依赖收集和派发更新)
             1、$mounted >> vm._render() (render watcher实例化) >> 调用相应的数据this.getter(vm, vm) 并且把dep.target赋值为当前的渲染watcher >> 触发getter并调用dep.depend() >> 执行this.dep.addDep() >> 把dep.target 压入subs栈中
             2、数据更新触发setter  >> dep.notify() >> 触发依赖的watcher，调用watcher.update() >> 更新视图

#### 9、Vue 中的 computed 是如何实现的(依赖需要是响应式数据)  

一、执行 initComputed 方法 >> 渲染过程中访问到计算属性的值 >> 调用computedGetter 函数（组件构造器定义时，defineProperty(targe, key, computedGetter)） >> 执行watcher.depend() (自身this.depend 依赖收集渲染watcher) >> （dirty true 时）调用watcher.evaluate()，进而调用this.get()进行求值 >> 求值过程中，Dep.target设置为computed watcher，并且调用computed中定义的函数，进而对依赖的响应式数据值进行访问 >> 触发数据的getter函数，调用dep.depend(), subs 里面的watcher 则为computed watcher, dirty 置为false >> 如果依赖数据更新，触发setter，dep.notify()通知的是computed watcher， 触发watcher.update >> 重新求值，和第一值进行对比，如果不同通知之前收集的渲染watcher.updete() 从而完成更新

#### 10、diff算法
